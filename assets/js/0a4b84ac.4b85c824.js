"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2774],{6261:e=>{e.exports=JSON.parse('{"blogPosts":[{"id":"testify-2","metadata":{"permalink":"/android-testify/blog/testify-2","editUrl":"https://github.com/ndtp/android-testify/tree/issue-12/docusaurus/docs/blog/2023-12-04-2.0-released.md","source":"@site/blog/2023-12-04-2.0-released.md","title":"Testify 2.0 \u2014 A New Era of Android Screenshot Testing","description":"Explore the latest features and improvements in Testify 2.0 for advanced Android screenshot testing.","date":"2023-12-04T00:00:00.000Z","formattedDate":"December 4, 2023","tags":[{"label":"android","permalink":"/android-testify/blog/tags/android"},{"label":"testing","permalink":"/android-testify/blog/tags/testing"},{"label":"UI","permalink":"/android-testify/blog/tags/ui"}],"readingTime":3.255,"truncated":false,"authors":[{"name":"Daniel Jette","title":"Core Contributor to Android Testify","url":"https://github.com/DanielJette","image_url":"https://github.com/DanielJette.png","imageURL":"https://github.com/DanielJette.png"}],"frontMatter":{"title":"Testify 2.0 \u2014 A New Era of Android Screenshot Testing","description":"Explore the latest features and improvements in Testify 2.0 for advanced Android screenshot testing.","slug":"testify-2","authors":[{"name":"Daniel Jette","title":"Core Contributor to Android Testify","url":"https://github.com/DanielJette","image_url":"https://github.com/DanielJette.png","imageURL":"https://github.com/DanielJette.png"}],"tags":["android","testing","UI"],"hide_table_of_contents":false},"nextItem":{"title":"Testify Embraces Semantic Versioning","permalink":"/android-testify/blog/semantic-versioning"}},"content":"We\'re thrilled to announce the stable release of Testify 2.0, a significant leap forward in Android Screenshot Testing! \ud83c\udf89 Testify empowers developers to enhance test coverage by including the UI layer in their testing, providing a robust tool for monitoring UI quality and detecting unintended changes in view rendering.\\n\\nWith Testify 2.0, effortlessly set up a variety of screenshot tests in your application, offering a new perspective for monitoring UI experiences and reviewing changes. This release marks a milestone, delivering a testing solution that seamlessly adapts to your needs, ensuring a dependable and feature-rich experience for Android developers. Establishing a comprehensive set of screenshot tests for your application has never been easier.\\n\\n## Key Goals of the Testify 2.0 Architecture\\n\\n### Core Functionality Separation\\n\\nTestify 2.0 focuses on providing a highly customizable and configurable core library with pre-built solutions for common testing scenarios. The new architecture separates the core screenshot functionality from the JUnit4 lifecycle and AndroidTestRule, opening up new possibilities for expansion, customization, and adaptation to multiple testing requirements.\\n\\n![Architecture Diagram](architecture-core.png)\\n\\nThe core library in Testify 2.0 is designed to support classic Android Views, Compose UI, and Surface Views. It is highly modular, offering a scalable, programmable, and extensible API set to cover a wide range of testing scenarios. The primary goal of the 2.0 architecture was to separate Testify into extensible and reusable components, allowing unparalleled customization to meet all of your testing needs. For example, the new `TestifyConfiguration` class allows you to easily configure and customize your screenshot tests to handle a multitude of UI setups.\\n\\nThe new `CaptureMethod` and `CompareMethod` interfaces allow you to write and plug-in any custom screenshot capture or comparison logic you desire.\\n\\nMany internal and helper functions are now available as public methods, allowing you to leverage Testify in new and original ways.\\n\\n### Plugins & Extensions\\n\\nA key feature of the Testify 2.0 architecture is its use of Plugins and Extensions.\\n\\n**Plugins** provide improvements to, and integrations with, common client-side development tools. Their goal is to improve developer productivity and happiness. The _**Gradle Plugin**_ offers tasks for recording baseline images, running tests, viewing diagnostics, and generating reports, while the _**IntelliJ Platform Plugin**_ provides GUI integration directly into Android Studio for accessing common actions.\\n\\n**Extensions** offer developers the opportunity to expand upon the existing Testify patterns by easily slotting in new functionality. Provided Testify Extensions allow for testing accessibility, composables from Jetpack Compose, or capturing the whole screen. These extensions can be used to improve the quality of your tests or perform advanced testing scenarios. Or, you may now easily provide your own extensions to further customize Testify.\\n\\nFor example, the _**Fullscreen Capture Method**_ allows you to capture the entire device screen, including system UI, dialogs, and menus.\\n\\nThe _**Accessibility Checks**_ extension allows you to combine visual regression testing with accessibility checks to further improve the quality and expand the reach of your application.\\n\\n### Sample Application Enhancements\\n\\nTestify 2.0 introduces additional, expressive sample codes to help get you started on with screenshot testing. You can now find examples showcasing Testify being used with **Jetpack Compose**, **Gradle Managed Devices**, **Dependency Injection**, and **Android Clean Architecture**.\\n\\nThe comprehensive set of sample applications demonstrate the usage of all public methods and extension libraries as well as providing examples of commonly tested scenarios.\\n\\n## How to Get Started\\n\\nTo explore the new features and improvements in Testify 2.0.0, follow our [documentation](https://ndtp.github.io/android-testify/docs/intro) for installation instructions and usage guidelines.\\n\\nTo learn how to tackle more advanced testing scenarios, check out our [Recipe Book](http://localhost:3000/android-testify/docs/category/recipes).\\n\\nWe encourage developers to provide feedback, report issues, and contribute to the Testify community on [GitHub](https://github.com/ndtp/android-testify/). Your insights help us make Testify even better!\\n\\nThank you for being a part of the Testify journey. Embrace the future of Android Screenshot Testing with Testify 2.0!\\n\\nHappy testing! \ud83d\udcf8\\n\\n---\\n\\n#### Changelog\\n\\nFor a detailed list of changes and enhancements in Testify 2.0.0, check out the [changelog](https://github.com/ndtp/android-testify/blob/main/CHANGELOG.md)."},{"id":"semantic-versioning","metadata":{"permalink":"/android-testify/blog/semantic-versioning","editUrl":"https://github.com/ndtp/android-testify/tree/issue-12/docusaurus/docs/blog/2023-11-14-semantic-versioning.md","source":"@site/blog/2023-11-14-semantic-versioning.md","title":"Testify Embraces Semantic Versioning","description":"Testify is gearing up for a significant change in its release strategy.","date":"2023-11-14T00:00:00.000Z","formattedDate":"November 14, 2023","tags":[{"label":"versioning","permalink":"/android-testify/blog/tags/versioning"},{"label":"releases","permalink":"/android-testify/blog/tags/releases"}],"readingTime":2.575,"truncated":false,"authors":[{"name":"Daniel Jette","title":"Core Contributor to Android Testify","url":"https://github.com/DanielJette","image_url":"https://github.com/DanielJette.png","imageURL":"https://github.com/DanielJette.png"}],"frontMatter":{"title":"Testify Embraces Semantic Versioning","description":"Testify is gearing up for a significant change in its release strategy.","slug":"semantic-versioning","authors":[{"name":"Daniel Jette","title":"Core Contributor to Android Testify","url":"https://github.com/DanielJette","image_url":"https://github.com/DanielJette.png","imageURL":"https://github.com/DanielJette.png"}],"tags":["versioning","releases"],"hide_table_of_contents":true},"prevItem":{"title":"Testify 2.0 \u2014 A New Era of Android Screenshot Testing","permalink":"/android-testify/blog/testify-2"},"nextItem":{"title":"Gradle Managed Devices Support","permalink":"/android-testify/blog/gradle-managed-device"}},"content":"Testify, the open-source library for Android Screenshot Testing, is gearing up for a significant change in its release strategy. We are excited to announce the adoption of Semantic Versioning, a standardized versioning system that promises to bring more clarity and efficiency to Testify\'s development process.\\n\\n---\\n\\nTestify empowers Android developers to effortlessly set up screenshot tests for their applications. Capturing screenshots offers a valuable tool for monitoring UI quality and reviewing changes efficiently. As Testify continues to evolve, we are making pivotal changes to our release process, transitioning to Semantic Versioning for a more streamlined and user-friendly experience.\\n\\nTestify currently follows a custom release process where Major Versions are set as milestones leading up to a complete feature set. This approach, while effective, has resulted in long release cycles, stretching over many month. This has prompted us to explore a more standardized versioning system for improved communication and quicker releases.\\n\\nThe decision to embrace Semantic Versioning is driven by a desire to move more quickly, providing more frequent changes while better communicating the risk of changes and backward compatibility expectations. This change aims to enhance the overall development experience for Testify users and contributors.\\n\\nThese changes will take effect following the public release of Testify 2.0.0 in late Q4, 2023.\\n\\n#### Benefits of Semantic Versioning\\n\\n- **More Agile Development:** Frequent releases for smaller, focused changes.\\n- **Improved Communication:** Clear versioning communicates the nature of changes effectively.\\n- **Clearer Backward Compatibility Expectations:** Users can quickly assess the risk associated with each release.\\n\\n### Release Cadence and Versioning Scheme\\n\\nTestify will adopt the three-component Semantic Versioning scheme and release cadence which aligns with industry best practices:\\n\\n- **Major Versions (X.0.0):** Significant changes, potentially including breaking API changes. Incremented for incompatible API changes.\\n- **Minor Versions (X.Y.0):** Backward-compatible additions of new features or enhancements. Increased for backward-compatible feature additions.\\n- **Patch Versions (X.Y.Z):** Backward-compatible bug fixes and minor improvements. Raised for backward-compatible bug fixes.\\n\\nUnder the new system, there will be no pre-release builds, and all changes will be categorized directly under the appropriate Semantic Version.\\n\\n### Communication Strategy\\n\\nTo keep the Testify community well-informed, we have devised a comprehensive communication strategy:\\n\\n- **Changelog:** A detailed changelog for all releases, available on [Testify.dev](https://testify.dev) and [GitHub](https://github.com/ndtp/android-testify/blob/main/CHANGELOG.md).\\n- **Blog Posts:** Major version updates will be accompanied by detailed blog posts on [Testify.dev](https://testify.dev/blog).\\n- **Documentation Updates:** Regular updates with every Major and Minor release.\\n\\nEnsuring the stability and backward compatibility of Testify is paramount. A robust set of regression tests will verify backward compatibility for each release.\\n\\n#### Community Involvement\\n\\nWe value community involvement and encourage users to actively participate:\\n\\n- **GitHub Interaction:** Log bugs, submit requests, and propose changes directly through the [GitHub repository](https://github.com/ndtp/android-testify/issues/new/choose).\\n- **Stack Overflow Tag:** Tag questions with `android-testify` on [Stack Overflow](https://stackoverflow.com/questions/tagged/android-testify) for community-driven support.\\n\\nTestify is on a journey of continuous improvement, and the adoption of Semantic Versioning is a crucial step in this evolution. We look forward to a more agile, transparent, and collaborative future with our vibrant community.\\n\\nStay tuned for more updates and releases as Testify embraces Semantic Versioning for a brighter tomorrow!"},{"id":"gradle-managed-device","metadata":{"permalink":"/android-testify/blog/gradle-managed-device","editUrl":"https://github.com/ndtp/android-testify/tree/issue-12/docusaurus/docs/blog/2023-09-23-gradle-managed-device.md","source":"@site/blog/2023-09-23-gradle-managed-device.md","title":"Gradle Managed Devices Support","description":"Gradle Managed Devices Support in Android Testify","date":"2023-09-23T00:00:00.000Z","formattedDate":"September 23, 2023","tags":[{"label":"gradle managed device","permalink":"/android-testify/blog/tags/gradle-managed-device"},{"label":"customization","permalink":"/android-testify/blog/tags/customization"}],"readingTime":3.68,"truncated":false,"authors":[{"name":"Daniel Jette","title":"Core Contributor to Android Testify","url":"https://github.com/DanielJette","image_url":"https://github.com/DanielJette.png","imageURL":"https://github.com/DanielJette.png"}],"frontMatter":{"title":"Gradle Managed Devices Support","description":"Gradle Managed Devices Support in Android Testify","slug":"gradle-managed-device","authors":[{"name":"Daniel Jette","title":"Core Contributor to Android Testify","url":"https://github.com/DanielJette","image_url":"https://github.com/DanielJette.png","imageURL":"https://github.com/DanielJette.png"}],"tags":["gradle managed device","customization"],"hide_table_of_contents":false},"prevItem":{"title":"Testify Embraces Semantic Versioning","permalink":"/android-testify/blog/semantic-versioning"},"nextItem":{"title":"Customizing Screenshot Instrumentation Annotation","permalink":"/android-testify/blog/custom-annotations"}},"content":"import OpenNew from \'@site/static/img/open_new.svg\';\\n\\n\\nWe\'re thrilled to unveil an exciting addition to Android Testify, our open source project revolutionizing the way you conduct screenshot tests for your Android applications. Introducing **Gradle Managed Devices Support**, a feature designed to streamline your testing process and enhance the overall efficiency of your UI testing suite.\\n\\n\\n---\\n\\n### Understanding Gradle Managed Devices\\n\\n[Gradle Managed Devices <OpenNew />](https://developer.android.com/studio/test/gradle-managed-devices) is a powerful capability that allows you to manage and control Android emulators directly through Gradle. This means you can easily set up and configure virtual devices for testing directly within your build scripts, automating the process and ensuring a consistent testing environment across various projects and team members.\\n\\n\\n### Why Use Gradle Managed Devices?\\n\\n1. **Consistency and Reproducibility:** By defining the emulator configurations in the Gradle build scripts, you ensure that all team members have access to the same testing setups. This promotes consistent testing across different development environments.\\n\\n2. **Simplified Configuration:** Managing emulators directly through Gradle simplifies the setup process for testing different resolutions, orientations, API versions, and languages. Developers can easily switch between configurations without manually adjusting emulator settings.\\n\\n3. **Integration with Continuous Integration:** Gradle Managed Devices seamlessly integrates with most Continuous Integration (CI) services, allowing for automated and reliable UI testing as part of your CI/CD pipeline.\\n\\nNow, let\'s delve into how you can leverage this new feature in Android Testify to optimize your UI testing workflow.\\n\\n### Using Gradle Managed Devices with Android Testify\\n\\nTo take advantage of Gradle Managed Devices support in Android Testify, follow these simple steps:\\n\\n1. **Upgrade Testify to Beta 4:** Update the classpath for the Testify plugin to version 2.0.0-beta04.\\n\\n```groovy\\nbuildscript {\\n    repositories {\\n        mavenCentral()\\n    }\\n    dependencies {\\n        classpath \\"dev.testify:plugin:2.0.0-beta04\\"\\n    }\\n}\\n```\\n\\n2. **Update Your Gradle Build File:** In your project\'s `build.gradle` file, ensure you have the necessary dependencies and configurations to enable Gradle Managed Devices support.\\n\\n```groovy\\nandroid {\\n  ...\\n  testOptions {\\n    managedDevices {\\n      devices {\\n        pixel2api30 (ManagedVirtualDevice) {\\n          // Use device profiles you typically see in Android Studio.\\n          device = \\"Pixel 2\\"\\n          // Use only API levels 27 and higher.\\n          apiLevel = 30\\n          // To include Google services, use \\"google\\".\\n          systemImageSource = \\"aosp\\"\\n        }\\n      }\\n    }\\n  }\\n}\\n```\\n\\nCustomize the `devices` block according to your specific testing needs, specifying the device name, API version, locale, and orientation.\\n\\n\\nIn addition, enable `TestStorageService` to receive screenshots after test execution:\\n\\n```groovy\\nandroid {\\n    defaultConfig {\\n        testInstrumentationRunnerArguments useTestStorageService: \\"true\\"\\n    }\\n}\\n\\ndependencies {\\n    androidTestUtil(\\"androidx.test.services:test-services:1.4.2\\")\\n}\\n```\\n\\n3. **Configure the Testify Library:** To instruct Testify to use Test Storage for storing screenshots and diffs, modify the Testify plugin configuration in your `build.gradle` file.\\n\\n```groovy\\ntestify {\\n  useTestStorage true\\n}\\n```\\n\\n### Running Screenshot Tests\\n\\n\\nTo perform screenshot test verification using the Gradle Managed Devices you configured, use the following command. `device-name` is the name of the device you configured in your Gradle build script (such as `pixel2api30`), and `BuildVariant` is the build variant of your app you want to test (such as `Debug`).\\n\\n```bash\\n./gradlew device-nameBuildVariantAndroidTest\\n```\\n\\n:::tip\\nDue to using Gradle Managed Devices using Test Storage to save screenshots, the `screenshotPull` task is unavailable. After execution, you can find any recorded screenshot in your module\'s `build/outputs/managed_device_android_test_additional_output/` folder.\\n:::\\n\\n\\n### Updating Baselines\\n\\nSince Gradle Managed Devices requires the use of their specific Gradle tasks, we cannot use the normal `screenshotRecord` task to udate our baselines. To generate a new baseline, you now have two options:\\n\\n1. **Enable Record Mode on the ScreenshotRule:** Apply necessary settings to the ScreenshotRule in Kotlin.\\n\\n```kotlin\\n@get:Rule val rule = ScreenshotRule(TestActivity::class.java)\\n\\n@ScreenshotInstrumentation\\n@Test\\nfun default() {\\n    rule\\n        .setRecordModeEnabled(true)\\n        .assertSame()\\n}\\n```\\n\\n2. **Enable the Testify Gradle Setting:** Enable record mode in the `build.gradle` file:\\n\\n```groovy\\ntestify {\\n    recordMode true\\n}\\n```\\n\\nOnce again, due to the specific Gradle task requirement, the `screenshotPull` task cannot be used. After execution, navigate to the module\'s `build/outputs/managed_device_android_test_additional_output/` folder and copy the recorded baseline into a folder named after your device configuration inside `androidTest/assets/screenshots/` directory.\\n\\n## Happy Testing\\n\\nWith these updates in place, you\'re now set to harness the potential of Gradle Managed Devices in Android Testify for enhanced screenshot tests.\\n\\n\\nWe\'re excited to see how this enhancement elevates your UI testing process with Android Testify. \\n\\nThis feature is still in beta, so please let us know if you have any questions or need further assistance in implementing this feature, feel free to reach out! Happy testing!\\n\\n[Stack Overflow](https://stackoverflow.com/questions/tagged/android-testify) | [GitHub Issues](https://github.com/ndtp/android-testify/issues)\\n\\n---"},{"id":"custom-annotations","metadata":{"permalink":"/android-testify/blog/custom-annotations","editUrl":"https://github.com/ndtp/android-testify/tree/issue-12/docusaurus/docs/blog/2023-04-25-custom-annotations.md","source":"@site/blog/2023-04-25-custom-annotations.md","title":"Customizing Screenshot Instrumentation Annotation","description":"Customizing Screenshot Instrumentation Annotation","date":"2023-04-25T00:00:00.000Z","formattedDate":"April 25, 2023","tags":[{"label":"annotations","permalink":"/android-testify/blog/tags/annotations"},{"label":"customization","permalink":"/android-testify/blog/tags/customization"}],"readingTime":1.61,"truncated":false,"authors":[{"name":"Daniel Jette","title":"Core Contributor to Android Testify","url":"https://github.com/DanielJette","image_url":"https://github.com/DanielJette.png","imageURL":"https://github.com/DanielJette.png"}],"frontMatter":{"title":"Customizing Screenshot Instrumentation Annotation","description":"Customizing Screenshot Instrumentation Annotation","slug":"custom-annotations","authors":[{"name":"Daniel Jette","title":"Core Contributor to Android Testify","url":"https://github.com/DanielJette","image_url":"https://github.com/DanielJette.png","imageURL":"https://github.com/DanielJette.png"}],"tags":["annotations","customization"],"hide_table_of_contents":false},"prevItem":{"title":"Gradle Managed Devices Support","permalink":"/android-testify/blog/gradle-managed-device"},"nextItem":{"title":"Accounting for platform differences","permalink":"/android-testify/blog/platform-differences"}},"content":"Testify is a powerful Android plugin that provides a selection of utility tasks for advanced use cases in screenshot testing. With Testify, developers can easily create, compare, and report screenshots of their app across different devices, locales, and screen sizes.\\n\\nIn the latest release of Testify, we\'ve added a new setting that allows developers to customize the instrumentation annotation used to identify which test is a screenshot test. This means that the @ScreenshotInstrumentation annotation is no longer a required element in your code.\\n\\n## Why This Change?\\n\\nThe @ScreenshotInstrumentation annotation was previously required for Testify to identify screenshot tests. This annotation added an additional layer of complexity to the testing process and could cause confusion for developers who were new to Testify. By introducing the ability to customize the annotation, we hope to simplify the testing process and make Testify more accessible to a wider range of developers.\\n\\n## How to Use the New Setting\\n\\nTo use the new Testify setting, developers can now add a `screenshotAnnotation` parameter to their build.gradle file. This parameter allows developers to specify the name of the annotation that they are using for their screenshot tests. Here\'s an example:\\n\\n```gradle\\ntestify {\\n  // Set the instrumentation annotation used for screenshot tests\\n  screenshotAnnotation = \\"com.example.MyScreenshotAnnotation\\"\\n}\\n```\\nIn this example, we\'re setting the screenshotAnnotation parameter to \\"com.example.MyScreenshotAnnotation\\". This tells Testify to look for tests annotated with @com.example.MyScreenshotAnnotation to identify screenshot tests.\\n\\nIf you don\'t specify a screenshotAnnotation, Testify will use the default @ScreenshotInstrumentation annotation.\\n\\n## Conclusion\\n\\nBy adding the ability to customize the instrumentation annotation used to identify screenshot tests, we\'ve made Testify even more powerful and accessible to developers. We hope that this new setting will simplify the testing process and make it easier for more developers to use Testify in their Android apps.\\n\\nIf you have any questions or feedback on this new feature, please don\'t hesitate to reach out to us on our [GitHub](https://github.com/ndtp/android-testify/issues) page."},{"id":"platform-differences","metadata":{"permalink":"/android-testify/blog/platform-differences","editUrl":"https://github.com/ndtp/android-testify/tree/issue-12/docusaurus/docs/blog/2023-02-13-platform-differences.md","source":"@site/blog/2023-02-13-platform-differences.md","title":"Accounting for platform differences","description":"This is my first post on Docusaurus 2.","date":"2023-02-13T00:00:00.000Z","formattedDate":"February 13, 2023","tags":[{"label":"differences","permalink":"/android-testify/blog/tags/differences"},{"label":"customization","permalink":"/android-testify/blog/tags/customization"}],"readingTime":6.9,"truncated":true,"authors":[{"name":"Daniel Jette","title":"Core Contributor to Android Testify","url":"https://github.com/DanielJette","image_url":"https://github.com/DanielJette.png","imageURL":"https://github.com/DanielJette.png"}],"frontMatter":{"title":"Accounting for platform differences","description":"This is my first post on Docusaurus 2.","slug":"platform-differences","authors":[{"name":"Daniel Jette","title":"Core Contributor to Android Testify","url":"https://github.com/DanielJette","image_url":"https://github.com/DanielJette.png","imageURL":"https://github.com/DanielJette.png"}],"tags":["differences","customization"],"hide_table_of_contents":false},"prevItem":{"title":"Customizing Screenshot Instrumentation Annotation","permalink":"/android-testify/blog/custom-annotations"}},"content":"export const Swatch = ({children, color}) => (\\n  <span\\n    style={{\\n      backgroundColor: color,\\n      borderRadius: \'2px\',\\n      color: \'#fff\',\\n      padding: \'0.2rem\'\\n    }}>\\n    {children}\\n  </span>\\n);\\n\\nA common problem when using Testify is having to deal with undesirable differences in your screenshots caused by variations in platforms or hardware. This blog will explain how to configure Testify to account for these differences.\\n\\n\x3c!--truncate--\x3e\\n\\n---\\n\\nMuch of the UI in Android is rendered with hardware acceleration. This means that both the GPU and CPU used by your test device will impact the rendering of your screenshots. Commonly, this is caused by subtle differences in floating point rounding.\\n\\nThe elements most frequently impacted by hardware accelerated rendering are:\\n\\n1. [Shadows & elevation](https://m1.material.io/material-design/elevation-shadows.html)\\n2. [Font smoothing & anti-aliasing](https://medium.com/@ali.muzaffar/android-why-your-canvas-shapes-arent-smooth-aa2a3f450eb5)\\n3. [Image decompression and rendering](https://en.wikipedia.org/wiki/Compression_artifact)\\n4. [Alpha blending, or alpha compositing](https://en.wikipedia.org/wiki/Alpha_compositing)\\n\\n## Background\\n\\nLet\u2019s walk through a brief example that explains how these small hardware differences can impact your captured screenshots.\\n\\nIn this example, our UI uses two ARGB colors which each have some transparency. These colors are defined as **ARGB(128,189,85,85)**<Swatch color=\\"#deaaaa\\">&nbsp;&nbsp;&nbsp;&nbsp;</Swatch> and **ARGB(128,0,161,254)**<Swatch color=\\"#7fd0fe\\">&nbsp;&nbsp;&nbsp;&nbsp;</Swatch>.\\n\\nIn hardware, those would be represented as floating point numbers: **(0.502f,&nbsp;0.741f,&nbsp;0.333f,&nbsp;0.333f)** and **(0.502f,&nbsp;0f,&nbsp;0.631f,&nbsp;0.996f)** respectively.\\n\\nIf we stack these two swatches on top of a pure white background, the GPU will composite the two colors together in such a way that they appear like the following opaque color in the UI: <br/>\\n**(1.0f,&nbsp;0.619f,&nbsp;0.572f,&nbsp;0.666f)**<Swatch color=\\"#9a92aa\\">&nbsp;&nbsp;&nbsp;&nbsp;</Swatch>.\\n\\nWhen capturing a screenshot, the onscreen image is saved to a bitmap file. Testify uses PNG files to store these images. During the capture process, the pixels are translated from the hardware representation to an integer representation by multiplying the floating point value by 255. Depending on many factors, the exact transformation that takes place can result in minor variations of the same values.\\n\\n\\n- `0.619f \xd7 255` might be rounded to 158 or truncated to 157\\n- `0.572f \xd7 255` might be rounded to 146 or truncated to 145\\n- `0.666f x 255` might be rounded to 170 or truncated to 169\\n\\nThis is generally regarded as a harmless or insignificant since the difference in the resulting colors will be imperceptible to the human eye.\\n\\n![](157145169.png) or ![](158146170.png)\\n\\nYes these are different!\\n\\nThis technique of blending two colors together is common in Android UI and so is a cause of many unintentional differences in your screenshot tests.\\n\\nIf you look at the hex representation of these two colors you can see that, mathematically speaking, these numbers are quite different from one another:\\n\\n`0x9D91A9` vs. `0x9E92AA`\\n\\nThis can cause significant problems for screenshot tests.\\n\\nA bit-based comparison will immediately fail due to the numbers not being identical.\\nEven a tolerance-based comparison will likely fail as the difference between the two numbers is `0x10101`, or 65,793!\\n\\n\\n## A common problem\\n\\nThese types of hardware rounding differences are very common. A variety of configuration options can impact the captured Testify images. The CPU (M1 or x86), the GPU (discrete or integrated), emulator image (arm64, x86 or x86_64) and emulated performance settings (number of CPU cores, emulated Graphics \u2013 Hardware or Software GLES 1.1 or GLES 2.0) will all impact the mathematical calculations that take part of the rendering and capture of any bitmaps by Testify.\\n\\nIn an ideal world, you would ensure that all devices in your testing environment are configured to use identical hardware and software settings. This would be the easiest way to avoid minor baseline image differences due to hardware variations.\\n\\nHowever, it is extremely common for teams to have a variety of hardware configurations in use and it can be impossible to standardize on any one specific configration. Many large teams employ a large variety of development hardware, and the hardware configuration of many Continuous Integration Services offer limited or no control over their hardware.\\n\\nIn fact, this is so common that Testify has built-in accomodations for such differences.\\n\\n## Capture screenshots at the highest quality\\n\\nBefore we can deal with these rendering irregularities, we need to first ensure we\'re capturing high-quality data. We need to set up the screenshot tests to capture the highest-quality screenshots possible.\\n\\n### Enable PixelCopyCapture\\n\\n[`PixelCopy`](https://developer.android.com/reference/android/view/PixelCopy) is a method provided by the Android SDK since API 24 which will faithfully capture the entire `Surface` presented in the UI to a `Bitmap`. This includes elevation, shadows and other GPU-accelerated rendering features.\\n\\nFor best results, it is recommended that you enable the `PixelCopyCapture` method in Testify.\\n\\nThere are three ways you can enable `PixelCopyCapture`:\\n\\n#### In your project manifest. \\n\\nYou can enable `PixelCopyCapture` in your `AndroidManifest.xml`. This way, this capture method will be used for all tests in your entire project.\\n\\n```xml\\n<manifest package=\\"dev.testify.sample\\"\\n  xmlns:android=\\"http://schemas.android.com/apk/res/android\\">\\n  <application>\\n    <meta-data android:name=\\"testify-pixelcopy-capture\\" android:value=\\"true\\" />\\n  </application>\\n</manifest>\\n```\\n#### In your test class\\n\\nYou can enable `PixelCopyCapture` for your test class by enabling the `PixelCopyCapture` feature flag in a `@Before` block. With this method, you will enable the `PixelCopyCapture` for every test method in your class.\\n\\n```kotlin\\n@Before\\nfun before() {\\n  TestifyFeatures.PixelCopyCapture.setEnabled(true)\\n}\\n```\\n\\n#### On your test rule\\n\\nYou can enable `PixelCopyCapture` on a case-by-case basis with the `withExperimentalFeatureEnabled()` modifier on `ScreenshotTestRule`.\\n\\n```kotlin\\n@get:Rule val rule = ScreenshotRule(MainActivity::class.java)\\n\\n@ScreenshotInstrumentation\\n@Test\\nfun testDefault() {\\n  rule\\n    .withExperimentalFeatureEnabled(TestifyFeatures.PixelCopyCapture)\\n    .assertSame()\\n}\\n```\\n\\n## Ignore unimportant differences\\n\\n\\nIn order to account for the large integer differences that can exist between two visually similar pixels, we need to employ some kind of smart tolerance or heuristic to intelligently exclude irrelevant differences yet still fail on meaningful changes to the UI.\\n\\nEven though the number variance may be large, the human eye may not be able to perceive the difference in color. Thankfully, there are multiple algorithms that can tell us the distinction between an unimportant or important changes.\\n\\n> _In color science, **color difference** or **color distance** is the separation between two colors. This metric allows quantified examination of a notion that formerly could only be described with adjectives._\\n> https://en.wikipedia.org/wiki/Color_difference#CIELAB_%CE%94E*\\n\\nOne such color distance algorithm is _Delta E_.\\n\\nThe Delta E algorithm can mathematically quantify the similarity between two different colors. It allows us to ignore the differences between two pixels that the human eye would consider identical while still identifying differences in position, size or layout. Uing Delta E when comparing two images provides a reasonable allowance for small differences in the rendered result that most of us would consider as being \u201cthe same\u201d.\\n\\nTestify has an optional implementation of the Delta E color distance algorithm which can be enabled with the `setExactness()` modifier.\\n\\n### Enable Delta E comparison with an exactness value of less than 1\\n\\nYou can enable the Delta E comparison method on the Testify rule using the [`setExactness()`](http://localhost:3000/android-testify/docs/recipes/tolerance) method.\\n\\nAny value less than `1.0f` will enable the Delta E comparison method. \\n\\nA value of `0.0f` will instruct the comparison method to ignore all differences, no matter how significant. A value of between `0.7f` and `0.9f` will generally be the \\"sweet spot\\" that will ignore the majority of minor rendering variations while still failing on significant layout changes. You can experiment with your tests to find which value is best for your environment. I\'d recommend starting with `0.9f` and reducing the value in increments of `0.05f` until all of your tests pass.\\n\\n:bookmark: The Delta E comparison implementation uses a coroutine worker pool to efficiently parallelize the comparison operation. As such, it is highly recommend that you enable Multi-Core CPU features on your test target emulator.\\n\\n#### Before each test\\n\\nYou can enable the Delta E comparison for all tests in a test class by enabling it on the `ScreenshotRule` in a `@Before` method.\\n\\n```kotlin\\n@get:Rule val rule = ScreenshotRule(MainActivity::class.java)\\n\\n@Before\\nfun before() {\\n  rule.setExactness(0.8f)\\n}\\n```\\n\\n#### For one test case\\n\\nYou can enable the Delta E comparison for a single test by enabling it on the `ScreenshotRule` in the body of the test method, prior to invoking `assertSame()`.\\n\\n```kotlin\\n@get:Rule val rule = ScreenshotRule(MainActivity::class.java)\\n\\n@ScreenshotInstrumentation\\n@Test\\nfun testDefault() {\\n  rule\\n    .setExactness(0.8f)\\n    .assertSame()\\n}\\n```\\n\\n## Conclusion\\n\\nA test failure should provide you with important, actionable information. Unimportant rendering differences should not cause your tests to fail. By using `PixelCopyCapture` with a tolerance of around `0.9f`, you can safely ignore unimportant differences in your screenshots caused by variations on your testing hardware. This allows you to work more efficiently with others and focus on the visual quality of your application."}]}')}}]);